//! Rust library for CCExtractor
//!
//! Currently we are in the process of porting the 708 decoder to rust. See [decoder]

// Allow C naming style
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/// CCExtractor C bindings generated by bindgen
#[allow(clippy::all)]
pub mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}
pub mod activity;
pub mod args;
pub mod ccx_encoders_helpers;
pub mod decoder;
pub mod enums;
#[cfg(feature = "hardsubx_ocr")]
pub mod hardsubx;
pub mod params;
pub mod structs;
pub mod utils;

#[cfg(windows)]
use std::os::windows::io::{FromRawHandle, RawHandle};
use std::{io::Write, os::raw::c_int};

use bindings::*;
use decoder::Dtvcc;
use utils::is_true;

use env_logger::{builder, Target};
use log::{warn, LevelFilter};

extern "C" {
    static mut cb_708: c_int;
    static mut cb_field1: c_int;
    static mut cb_field2: c_int;
}

/// Initialize env logger with custom format, using stdout as target
#[no_mangle]
pub extern "C" fn ccxr_init_logger() {
    builder()
        .format(|buf, record| writeln!(buf, "[CEA-708] {}", record.args()))
        .filter_level(LevelFilter::Debug)
        .target(Target::Stdout)
        .init();
}

/// Process cc_data
///
/// # Safety
/// dec_ctx should not be a null pointer
/// data should point to cc_data of length cc_count
#[no_mangle]
extern "C" fn ccxr_process_cc_data(
    dec_ctx: *mut lib_cc_decode,
    data: *const ::std::os::raw::c_uchar,
    cc_count: c_int,
) -> c_int {
    let mut ret = -1;
    let mut cc_data: Vec<u8> = (0..cc_count * 3)
        .map(|x| unsafe { *data.add(x as usize) })
        .collect();
    let dec_ctx = unsafe { &mut *dec_ctx };
    let dtvcc_ctx = unsafe { &mut *dec_ctx.dtvcc };
    let mut dtvcc = Dtvcc::new(dtvcc_ctx);
    for cc_block in cc_data.chunks_exact_mut(3) {
        if !validate_cc_pair(cc_block) {
            continue;
        }
        let success = do_cb(dec_ctx, &mut dtvcc, cc_block);
        if success {
            ret = 0;
        }
    }
    ret
}

/// Returns `true` if cc_block pair is valid
///
/// For CEA-708 data, only cc_valid is checked
/// For CEA-608 data, parity is also checked
pub fn validate_cc_pair(cc_block: &mut [u8]) -> bool {
    let cc_valid = (cc_block[0] & 4) >> 2;
    let cc_type = cc_block[0] & 3;
    if cc_valid == 0 {
        return false;
    }
    if cc_type == 0 || cc_type == 1 {
        // For CEA-608 data we verify parity.
        if verify_parity(cc_block[2]) {
            // If the second byte doesn't pass parity, ignore pair
            return false;
        }
        if verify_parity(cc_block[1]) {
            // If the first byte doesn't pass parity,
            // we replace it with a solid blank and process the pair.
            cc_block[1] = 0x7F;
        }
    }
    true
}

/// Returns `true` if data has odd parity
///
/// CC uses odd parity (i.e., # of 1's in byte is odd.)
pub fn verify_parity(data: u8) -> bool {
    if data.count_ones() & 1 == 1 {
        return true;
    }
    false
}

/// Process CC data according to its type
pub fn do_cb(ctx: &mut lib_cc_decode, dtvcc: &mut Dtvcc, cc_block: &[u8]) -> bool {
    let cc_valid = (cc_block[0] & 4) >> 2;
    let cc_type = cc_block[0] & 3;
    let mut timeok = true;

    if ctx.write_format != ccx_output_format::CCX_OF_DVDRAW
        && ctx.write_format != ccx_output_format::CCX_OF_RAW
        && (cc_block[0] == 0xFA || cc_block[0] == 0xFC || cc_block[0] == 0xFD)
        && (cc_block[1] & 0x7F) == 0
        && (cc_block[2] & 0x7F) == 0
    {
        return true;
    }

    if cc_valid == 1 || cc_type == 3 {
        ctx.cc_stats[cc_type as usize] += 1;
        match cc_type {
            // Type 0 and 1 are for CEA-608 data. Handled by C code, do nothing
            0 | 1 => {}
            // Type 2 and 3 are for CEA-708 data.
            2 | 3 => {
                let current_time = unsafe { (*ctx.timing).get_fts(ctx.current_field as u8) };
                ctx.current_field = 3;

                // Check whether current time is within start and end bounds
                if is_true(ctx.extraction_start.set)
                    && current_time < ctx.extraction_start.time_in_ms
                {
                    timeok = false;
                }
                if is_true(ctx.extraction_end.set) && current_time > ctx.extraction_end.time_in_ms {
                    timeok = false;
                    ctx.processed_enough = 1;
                }

                if timeok && ctx.write_format != ccx_output_format::CCX_OF_RAW {
                    dtvcc.process_cc_data(cc_valid, cc_type, cc_block[1], cc_block[2]);
                }
                unsafe { cb_708 += 1 }
            }
            _ => warn!("Invalid cc_type"),
        }
    }
    true
}

#[cfg(windows)]
#[no_mangle]
extern "C" fn ccxr_close_handle(handle: RawHandle) {
    use std::fs::File;

    if handle.is_null() {
        return;
    }
    unsafe {
        // File will close automatically (due to Drop) once it goes out of scope
        let _file = File::from_raw_handle(handle);
    }
}

#[cfg(test)]
pub mod tests {
    pub mod params {
        use crate::{args::*, enums::*, params::*, structs::*};
        use clap::Parser;

        #[test]
        fn broken_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "srt",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn broken_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "sami",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.write_format, CcxOutputFormat::Sami);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn broken_3() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "ttxt",
                "--latin1",
                "--ucla",
                "--xds",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
            assert!(opt.ucla);
            assert!(opt.transcript_settings.xds);
        }

        #[test]
        fn broken_4() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--out",
                "ttxt",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn broken_5() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--out", "srt", "--latin1"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn cea708_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--service",
                "1",
                "--out",
                "txt",
                "--no-bom",
                "--no-rollup",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.is_708_enabled);
            assert!(opt.enc_cfg.no_bom);
            assert!(opt.no_rollup);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
        }

        #[test]
        fn cea708_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--service",
                "1,2[UTF-8],3[EUC-KR],54",
                "--out",
                "txt",
                "--no-rollup",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            println!("{:?}", opt.enc_cfg.services_charsets);

            assert!(opt.is_708_enabled);
            assert!(opt.no_rollup);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.services_charsets[1], "UTF-8");
            assert_eq!(opt.enc_cfg.services_charsets[2], "EUC-KR");
        }

        #[test]
        fn cea708_3() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--service",
                "all[EUC-KR]",
                "--no-rollup",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.is_708_enabled);
            assert!(opt.no_rollup);
            assert_eq!(opt.enc_cfg.all_services_charset, "EUC-KR");
        }

        #[test]
        fn dvb_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "srt",
                "--latin1",
                "--teletext",
                "--datapid",
                "5603",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.demux_cfg.ts_cappids[0], 5603);
            assert_eq!(opt.demux_cfg.nb_ts_cappid, 1);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn dvb_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--stdout",
                "--quiet",
                "--no-fontcolor",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.cc_to_stdout);
            assert_eq!(opt.messages_target.unwrap(), 0);
            assert_eq!(opt.nofontcolor, true);
        }

        #[test]
        fn dvd_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "ttxt",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn dvr_ms_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--wtvconvertfix",
                "--autoprogram",
                "--out",
                "srt",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.wtvconvertfix);
            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn general_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--ucla",
                "--autoprogram",
                "--out",
                "ttxt",
                "--latin1",
                "--output-field",
                "field2",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.ucla);
            assert!(opt.demux_cfg.ts_autoprogram);
            assert!(opt.is_608_enabled);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.extract.unwrap(), OutputField::Field2);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn general_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "bin",
                "--latin1",
                "--sentencecap",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert!(opt.enc_cfg.sentence_cap);
            assert_eq!(opt.write_format, CcxOutputFormat::Rcwt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn haup_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--hauppauge",
                "--ucla",
                "--autoprogram",
                "--out",
                "ttxt",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.ucla);
            assert!(opt.hauppauge_mode);
            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn mp4_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--input",
                "mp4",
                "--out",
                "srt",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.demux_cfg.auto_stream, CcxStreamMode::Mp4);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn mp4_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "srt",
                "--bom",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert!(!opt.enc_cfg.no_bom);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn nocc_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "ttxt",
                "--mp4vidtrack",
                "--latin1",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert!(opt.mp4vidtrack);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn nocc_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "ttxt",
                "--latin1",
                "--ucla",
                "--xds",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert!(opt.ucla);
            assert!(opt.transcript_settings.xds);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn options_1() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--input", "ts"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.demux_cfg.auto_stream, CcxStreamMode::Transport);
        }

        #[test]
        fn options_2() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--out", "dvdraw"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.write_format, CcxOutputFormat::Dvdraw);
        }

        #[test]
        fn options_3() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--goptime"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.use_gop_as_pts, 1);
        }

        #[test]
        fn options_4() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--no-goptime"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.use_gop_as_pts, -1);
        }

        #[test]
        fn options_5() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--fixpadding"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.fix_padding);
        }

        #[test]
        fn options_6() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--90090"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            unsafe {
                assert_eq!(MPEG_CLOCK_FREQ, 90090);
            }
        }

        #[test]
        fn options_7() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--myth"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.auto_myth.unwrap(), 1);
        }

        #[test]
        fn options_8() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--program-number", "1"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.demux_cfg.ts_forced_program, 1);
        }

        #[test]
        fn options_9() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--datastreamtype",
                "2",
                "--streamtype",
                "2",
                "--no-autotimeref",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.noautotimeref);
            assert_eq!(opt.demux_cfg.ts_datastreamtype, 2);
            assert_eq!(opt.demux_cfg.ts_forced_streamtype, 2);
        }
        #[test]
        fn options_10() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--unicode",
                "--no-typesetting",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.notypesetting);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Unicode);
        }

        #[test]
        fn options_11() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--utf8", "--trim"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.enc_cfg.trim_subs);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Utf8);
        }

        #[test]
        fn options_12() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--capfile",
                "tests/resources/dictionary.txt",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.enc_cfg.sentence_cap);
            assert_eq!(
                opt.sentence_cap_file.unwrap(),
                "tests/resources/dictionary.txt"
            );
        }

        #[test]
        fn options_13() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--unixts",
                "5",
                "--out",
                "txt",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);
            unsafe {
                assert_eq!(UTC_REFVALUE, 5);
            }

            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
        }

        #[test]
        fn options_14() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--datets", "--out", "txt"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.date, CcxOutputDateFormat::Date);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
        }

        #[test]
        fn options_15() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--sects", "--out", "txt"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.date, CcxOutputDateFormat::Seconds);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
        }

        #[test]
        fn options_16() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--lf", "--out", "txt"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.enc_cfg.line_terminator_lf);
            assert_eq!(opt.write_format, CcxOutputFormat::Transcript);
        }

        #[test]
        fn options_17() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--autodash", "--trim"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.enc_cfg.autodash);
            assert!(opt.enc_cfg.trim_subs);
        }

        #[test]
        fn options_18() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--bufferinput"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.buffer_input);
        }

        #[test]
        fn options_19() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--no-bufferinput"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(!opt.buffer_input);
        }

        #[test]
        fn options_20() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--buffersize", "1M"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            unsafe {
                assert_eq!(FILEBUFFERSIZE, 1024 * 1024);
            }
        }

        #[test]
        fn options_21() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--dru"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.settings_608.direct_rollup, 1);
        }

        #[test]
        fn options_22() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--no-rollup"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.no_rollup);
        }

        #[test]
        fn options_23() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--rollup", "ru1"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.settings_608.force_rollup, 1);
        }

        #[test]
        fn options_24() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--delay", "200"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.subs_delay, 200);
        }

        #[test]
        fn options_25() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--startat",
                "4",
                "--endat",
                "7",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.extraction_start.ss, 4);
        }

        #[test]
        fn options_26() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--no-codec", "dvbsub"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.demux_cfg.nocodec, CcxCodeType::Dvb);
        }

        #[test]
        fn options_27() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--debug"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Verbose);
        }

        #[test]
        fn options_28() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--608"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Decoder608);
        }

        #[test]
        fn options_29() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--708"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Parse);
        }

        #[test]
        fn options_30() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--goppts"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Time);
        }

        #[test]
        fn options_31() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--xdsdebug"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::DecoderXds);
        }

        #[test]
        fn options_32() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--vides"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Vides);
        }

        #[test]
        fn options_33() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--cbraw"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Cbraw);
        }

        #[test]
        fn options_34() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--no-sync"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.nosync);
        }

        #[test]
        fn options_35() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--fullbin"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.fullbin);
        }

        #[test]
        fn options_36() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--parsedebug"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Parse);
        }

        #[test]
        fn options_37() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--parsePAT"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Pat);
        }

        #[test]
        fn options_38() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--parsePMT"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Pmt);
        }

        #[test]
        fn options_39() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--investigate-packets"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.investigate_packets);
        }

        #[test]
        fn options_40() {
            let args: Args =
                Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--mp4vidtrack"])
                    .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.mp4vidtrack);
        }

        #[test]
        fn options_41() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--wtvmpeg2"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.wtvmpeg2);
        }

        #[test]
        fn options_42() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--hauppauge"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.hauppauge_mode);
        }

        #[test]
        fn options_43() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--xmltv",
                "1",
                "--out",
                "null",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.xmltv.unwrap(), 1);
            assert_eq!(opt.write_format, CcxOutputFormat::Null);
        }

        #[test]
        fn options_44() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--codec",
                "dvbsub",
                "--out",
                "spupng",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.demux_cfg.codec, CcxCodeType::Dvb);
            assert_eq!(opt.write_format, CcxOutputFormat::Spupng);
        }

        #[test]
        fn options_45() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--startcreditsnotbefore",
                "1",
                "--startcreditstext",
                "CCextractor Start credit Testing",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.enc_cfg.startcreditsnotbefore.ss, 1);
            assert_eq!(
                opt.enc_cfg.start_credits_text,
                "CCextractor Start credit Testing"
            );
        }

        #[test]
        fn options_46() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--startcreditsnotafter",
                "2",
                "--startcreditstext",
                "CCextractor Start credit Testing",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.enc_cfg.startcreditsnotafter.ss, 2);
            assert_eq!(
                opt.enc_cfg.start_credits_text,
                "CCextractor Start credit Testing"
            );
        }

        #[test]
        fn options_47() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--startcreditsforatleast",
                "1",
                "--startcreditstext",
                "CCextractor Start credit Testing",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.enc_cfg.startcreditsforatleast.ss, 1);
            assert_eq!(
                opt.enc_cfg.start_credits_text,
                "CCextractor Start credit Testing"
            );
        }

        #[test]
        fn options_48() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--startcreditsforatmost",
                "2",
                "--startcreditstext",
                "CCextractor Start credit Testing",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.enc_cfg.startcreditsforatmost.ss, 2);
            assert_eq!(
                opt.enc_cfg.start_credits_text,
                "CCextractor Start credit Testing"
            );
        }

        #[test]
        fn options_49() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--endcreditsforatleast",
                "3",
                "--endcreditstext",
                "CCextractor Start credit Testing",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.enc_cfg.endcreditsforatleast.ss, 3);
            assert_eq!(
                opt.enc_cfg.end_credits_text,
                "CCextractor Start credit Testing"
            );
        }

        #[test]
        fn options_50() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--endcreditsforatmost",
                "2",
                "--endcreditstext",
                "CCextractor Start credit Testing",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert_eq!(opt.enc_cfg.endcreditsforatmost.ss, 2);
            assert_eq!(
                opt.enc_cfg.end_credits_text,
                "CCextractor Start credit Testing"
            );
        }

        #[test]
        fn options_51() {
            let args: Args = Args::try_parse_from(vec!["<PROGRAM NAME>", "myfile", "--tverbose"])
                .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };
            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(tlt_config.verbose);
            assert_eq!(opt.debug_mask, CcxDebugMessageTypes::Teletext);
        }

        #[test]
        fn teletext_1() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "srt",
                "--latin1",
                "--datapid",
                "2310",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.demux_cfg.ts_cappids[0], 2310);
            assert_eq!(opt.demux_cfg.nb_ts_cappid, 1);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }

        #[test]
        fn teletext_2() {
            let args: Args = Args::try_parse_from(vec![
                "<PROGRAM NAME>",
                "myfile",
                "--autoprogram",
                "--out",
                "srt",
                "--latin1",
                "--teletext",
                "--tpage",
                "398",
            ])
            .expect("Failed to parse arguments");
            let mut opt: CcxSOptions = CcxSOptions {
                ..Default::default()
            };
            let mut tlt_config = CcxSTeletextConfig {
                ..Default::default()
            };

            parse_parameters(&mut opt, &args, &mut tlt_config);

            assert!(opt.demux_cfg.ts_autoprogram);
            assert_eq!(opt.demux_cfg.codec, CcxCodeType::Teletext);
            assert_eq!(tlt_config.page, 398);
            assert_eq!(opt.write_format, CcxOutputFormat::Srt);
            assert_eq!(opt.enc_cfg.encoding, CcxEncodingType::Latin1);
        }
    }
}
