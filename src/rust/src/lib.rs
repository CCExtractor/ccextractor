//! Rust library for CCExtractor
//!
//! Currently we are in the process of porting the 708 decoder to rust. See [decoder]

// Allow C naming style
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/// CCExtractor C bindings generated by bindgen
#[allow(clippy::all)]
pub mod bindings {
    include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

// Constants from ccx_decoders_structs.h
pub const MAXBFRAMES: usize = 50;
pub const SORTBUF: usize = 2 * MAXBFRAMES + 1;

pub mod args;
pub mod common;
pub mod decoder;
#[cfg(feature = "hardsubx_ocr")]
pub mod hardsubx;
pub mod libccxr_exports;
pub mod parser;
pub mod utils;

#[cfg(windows)]
use std::os::windows::io::{FromRawHandle, RawHandle};

use args::Args;
use bindings::*;
use clap::{error::ErrorKind, Parser};
use common::{copy_from_rust, CType, CType2};
use decoder::Dtvcc;
use lib_ccxr::{common::Options, teletext::TeletextConfig, util::log::ExitCause};
use parser::OptionsExt;
use utils::is_true;

use env_logger::{builder, Target};
use log::{warn, LevelFilter};
use std::{
    ffi::CStr,
    io::Write,
    os::raw::{c_char, c_double, c_int, c_long, c_uint, c_void},
};

// Add a new field to store the Rust Dtvcc instance
#[repr(C)]
pub struct lib_cc_decode {
    pub dtvcc_rust: *mut Dtvcc<'static>,
    pub dtvcc: *mut dtvcc_ctx,
    pub write_format: ccx_output_format,
    pub cc_stats: [c_int; 4],
    pub timing: *mut ccx_common_timing_ctx,
    pub current_field: c_int,
    pub extraction_start: ccx_boundary_time,
    pub extraction_end: ccx_boundary_time,
    pub processed_enough: c_int,
    pub saw_caption_block: c_int,
    pub context_cc608_field_1: *mut c_void,
    pub context_cc608_field_2: *mut c_void,
    pub no_rollup: c_int,
    pub noscte20: c_int,
    pub fix_padding: c_int,
    pub subs_delay: i64,
    pub extract: c_int,
    pub fullbin: c_int,
    pub dec_sub: cc_subtitle,
    pub in_bufferdatatype: ccx_bufferdata_type,
    pub hauppauge_mode: c_uint,
    pub frames_since_last_gop: c_int,
    pub saw_gop_header: c_int,
    pub max_gop_length: c_int,
    pub last_gop_length: c_int,
    pub total_pulldownfields: c_uint,
    pub total_pulldownframes: c_uint,
    pub program_number: c_int,
    pub list: list_head,
    pub codec: ccx_code_type,
    pub has_ccdata_buffered: c_int,
    pub is_alloc: c_int,
    pub avc_ctx: *mut avc_ctx,
    pub private_data: *mut c_void,
    pub current_hor_size: c_uint,
    pub current_vert_size: c_uint,
    pub current_aspect_ratio: c_uint,
    pub current_frame_rate: c_uint,
    pub no_bitstream_error: c_int,
    pub saw_seqgoppic: c_int,
    pub in_pic_data: c_int,
    pub current_progressive_sequence: c_uint,
    pub current_pulldownfields: c_uint,
    pub temporal_reference: c_int,
    pub picture_coding_type: ccx_frame_type,
    pub num_key_frames: c_uint,
    pub picture_structure: c_uint,
    pub repeat_first_field: c_uint,
    pub progressive_frame: c_uint,
    pub pulldownfields: c_uint,
    pub top_field_first: c_uint,
    pub stat_numuserheaders: c_int,
    pub stat_dvdccheaders: c_int,
    pub stat_scte20ccheaders: c_int,
    pub stat_replay5000headers: c_int,
    pub stat_replay4000headers: c_int,
    pub stat_dishheaders: c_int,
    pub stat_hdtv: c_int,
    pub stat_divicom: c_int,
    pub false_pict_header: c_int,
    pub maxtref: c_int,
    pub cc_data_count: [c_int; SORTBUF],
    pub cc_fts: [i64; SORTBUF],
    pub cc_data_pkts: [[u8; 10*31*3+1]; SORTBUF],
    pub anchor_seq_number: c_int,
    pub xds_ctx: *mut ccx_decoders_xds_context,
    pub vbi_decoder: *mut ccx_decoder_vbi_ctx,
    pub writedata: Option<unsafe extern "C" fn(data: *const u8, length: c_int, private_data: *mut c_void, sub: *mut cc_subtitle) -> c_int>,
    pub ocr_quantmode: c_int,
    pub prev: *mut lib_cc_decode,
}

// Define the ccx_boundary_time struct
#[repr(C)]
#[derive(Default)]
pub struct ccx_boundary_time {
    pub hh: c_int,
    pub mm: c_int,
    pub ss: c_int,
    pub time_in_ms: i64,
    pub set: c_int,
}

#[cfg(test)]
static mut cb_708: c_int = 0;
#[cfg(test)]
static mut cb_field1: c_int = 0;
#[cfg(test)]
static mut cb_field2: c_int = 0;

#[cfg(not(test))]
extern "C" {
    static mut cb_708: c_int;
    static mut cb_field1: c_int;
    static mut cb_field2: c_int;
}

#[allow(dead_code)]
extern "C" {
    static mut usercolor_rgb: [c_int; 8];
    static mut FILEBUFFERSIZE: c_int;
    static mut MPEG_CLOCK_FREQ: c_int;
    static mut tlt_config: ccx_s_teletext_config;
    static mut ccx_options: ccx_s_options;
    static mut pts_big_change: c_uint;
    static mut current_fps: c_double;
    static mut frames_since_ref_time: c_int;
    static mut total_frames_count: c_uint;
    static mut gop_time: gop_time_code;
    static mut first_gop_time: gop_time_code;
    static mut fts_at_gop_start: c_long;
    static mut gop_rollover: c_int;
    static mut ccx_common_timing_settings: ccx_common_timing_settings_t;
    static mut capitalization_list: word_list;
    static mut profane: word_list;
}

/// Initialize env logger with custom format, using stdout as target
#[no_mangle]
pub extern "C" fn ccxr_init_logger() {
    builder()
        .format(|buf, record| writeln!(buf, "[CEA-708] {}", record.args()))
        .filter_level(LevelFilter::Debug)
        .target(Target::Stdout)
        .init();
}

/// Initialize a new Dtvcc instance and store it in the lib_cc_decode struct
#[no_mangle]
pub extern "C" fn ccxr_dtvcc_init(dec_ctx: *mut lib_cc_decode) -> c_int {
    if dec_ctx.is_null() {
        return -1;
    }
    
    let dec_ctx = unsafe { &mut *dec_ctx };
    if dec_ctx.dtvcc.is_null() {
        return -1;
    }
    
    let dtvcc_ctx = unsafe { &mut *dec_ctx.dtvcc };
    let dtvcc = Box::new(Dtvcc::new(dtvcc_ctx));
    dec_ctx.dtvcc_rust = Box::into_raw(dtvcc) as *mut Dtvcc<'static>;
    
    0
}

/// Free the Dtvcc instance stored in the lib_cc_decode struct
#[no_mangle]
pub extern "C" fn ccxr_dtvcc_free(dec_ctx: *mut lib_cc_decode) {
    if dec_ctx.is_null() {
        return;
    }
    
    let dec_ctx = unsafe { &mut *dec_ctx };
    if !dec_ctx.dtvcc_rust.is_null() {
        unsafe {
            let _ = Box::from_raw(dec_ctx.dtvcc_rust);
        }
        dec_ctx.dtvcc_rust = std::ptr::null_mut();
    }
}

/// Process cc_data
///
/// # Safety
/// dec_ctx should not be a null pointer
/// data should point to cc_data of length cc_count
#[no_mangle]
extern "C" fn ccxr_process_cc_data(
    dec_ctx: *mut lib_cc_decode,
    data: *const ::std::os::raw::c_uchar,
    cc_count: c_int,
) -> c_int {
    let mut ret = -1;
    let mut cc_data: Vec<u8> = (0..cc_count * 3)
        .map(|x| unsafe { *data.add(x as usize) })
        .collect();
    let dec_ctx = unsafe { &mut *dec_ctx };
    
    // Use the stored Dtvcc instance instead of creating a new one
    if dec_ctx.dtvcc_rust.is_null() {
        // If dtvcc_rust is null, initialize it
        if ccxr_dtvcc_init(dec_ctx) != 0 {
            // If initialization fails, fall back to the old method
            let dtvcc_ctx = unsafe { &mut *dec_ctx.dtvcc };
            let mut dtvcc = Dtvcc::new(dtvcc_ctx);
            
            for cc_block in cc_data.chunks_exact_mut(3) {
                if !validate_cc_pair(cc_block) {
                    continue;
                }
                let success = do_cb(dec_ctx, &mut dtvcc, cc_block);
                if success {
                    ret = 0;
                }
            }
            return ret;
        }
    }
    
    let dtvcc = unsafe { &mut *dec_ctx.dtvcc_rust };
    
    for cc_block in cc_data.chunks_exact_mut(3) {
        if !validate_cc_pair(cc_block) {
            continue;
        }
        let success = do_cb(dec_ctx, dtvcc, cc_block);
        if success {
            ret = 0;
        }
    }
    ret
}

/// Returns `true` if cc_block pair is valid
///
/// For CEA-708 data, only cc_valid is checked
/// For CEA-608 data, parity is also checked
pub fn validate_cc_pair(cc_block: &mut [u8]) -> bool {
    let cc_valid = (cc_block[0] & 4) >> 2;
    let cc_type = cc_block[0] & 3;
    if cc_valid == 0 {
        return false;
    }
    if cc_type == 0 || cc_type == 1 {
        // For CEA-608 data we verify parity.
        if verify_parity(cc_block[2]) {
            // If the second byte doesn't pass parity, ignore pair
            return false;
        }
        if verify_parity(cc_block[1]) {
            // If the first byte doesn't pass parity,
            // we replace it with a solid blank and process the pair.
            cc_block[1] = 0x7F;
        }
    }
    true
}

/// Returns `true` if data has odd parity
///
/// CC uses odd parity (i.e., # of 1's in byte is odd.)
pub fn verify_parity(data: u8) -> bool {
    if data.count_ones() & 1 == 1 {
        return true;
    }
    false
}

/// Process CC data according to its type
pub fn do_cb(ctx: &mut lib_cc_decode, dtvcc: &mut Dtvcc, cc_block: &[u8]) -> bool {
    let cc_valid = (cc_block[0] & 4) >> 2;
    let cc_type = cc_block[0] & 3;
    let mut timeok = true;

    if ctx.write_format != ccx_output_format::CCX_OF_DVDRAW
        && ctx.write_format != ccx_output_format::CCX_OF_RAW
        && (cc_block[0] == 0xFA || cc_block[0] == 0xFC || cc_block[0] == 0xFD)
        && (cc_block[1] & 0x7F) == 0
        && (cc_block[2] & 0x7F) == 0
    {
        return true;
    }

    if cc_valid == 1 || cc_type == 3 {
        ctx.cc_stats[cc_type as usize] += 1;
        match cc_type {
            // Type 0 and 1 are for CEA-608 data. Handled by C code, do nothing
            0 | 1 => {}
            // Type 2 and 3 are for CEA-708 data.
            2 | 3 => {
                let current_time = unsafe { (*ctx.timing).get_fts(ctx.current_field as u8) };
                ctx.current_field = 3;

                // Check whether current time is within start and end bounds
                if is_true(ctx.extraction_start.set)
                    && current_time < ctx.extraction_start.time_in_ms
                {
                    timeok = false;
                }
                if is_true(ctx.extraction_end.set) && current_time > ctx.extraction_end.time_in_ms {
                    timeok = false;
                    ctx.processed_enough = 1;
                }

                if timeok && ctx.write_format != ccx_output_format::CCX_OF_RAW {
                    dtvcc.process_cc_data(cc_valid, cc_type, cc_block[1], cc_block[2]);
                }
                unsafe { cb_708 += 1 }
            }
            _ => warn!("Invalid cc_type"),
        }
    }
    true
}

#[cfg(windows)]
#[no_mangle]
extern "C" fn ccxr_close_handle(handle: RawHandle) {
    use std::fs::File;

    if handle.is_null() {
        return;
    }
    unsafe {
        // File will close automatically (due to Drop) once it goes out of scope
        let _file = File::from_raw_handle(handle);
    }
}

extern "C" {
    fn version(location: *const c_char);
    #[allow(dead_code)]
    fn set_binary_mode();
}

/// # Safety
/// Safe if argv is a valid pointer
///
/// Parse parameters from argv and argc
#[no_mangle]
pub unsafe extern "C" fn ccxr_parse_parameters(argc: c_int, argv: *mut *mut c_char) -> c_int {
    // Convert argv to Vec<String> and pass it to parse_parameters
    let args = std::slice::from_raw_parts(argv, argc as usize)
        .iter()
        .map(|&arg| {
            CStr::from_ptr(arg)
                .to_str()
                .expect("Invalid UTF-8 sequence in argument")
                .to_owned()
        })
        .collect::<Vec<String>>();

    if args.len() <= 1 {
        return ExitCause::NoInputFiles.exit_code();
    }

    let args: Args = match Args::try_parse_from(args) {
        Ok(args) => args,
        Err(e) => {
            // Not all errors are actual errors, some are just help or version
            // So handle them accordingly
            match e.kind() {
                ErrorKind::DisplayHelp => {
                    // Print the help string
                    println!("{}", e);
                    return ExitCause::WithHelp.exit_code();
                }
                ErrorKind::DisplayVersion => {
                    version(*argv);
                    return ExitCause::WithHelp.exit_code();
                }
                ErrorKind::UnknownArgument => {
                    println!("Unknown Argument");
                    println!("{}", e);
                    return ExitCause::MalformedParameter.exit_code();
                }
                _ => {
                    println!("{}", e);
                    return ExitCause::Failure.exit_code();
                }
            }
        }
    };

    let mut _capitalization_list: Vec<String> = Vec::new();
    let mut _profane: Vec<String> = Vec::new();

    let mut opt = Options::default();
    let mut _tlt_config = TeletextConfig::default();

    opt.parse_parameters(
        &args,
        &mut _tlt_config,
        &mut _capitalization_list,
        &mut _profane,
    );
    tlt_config = _tlt_config.to_ctype(&opt);

    // Convert the rust struct (CcxOptions) to C struct (ccx_s_options), so that it can be used by the C code
    copy_from_rust(&raw mut ccx_options, opt);

    if !_capitalization_list.is_empty() {
        capitalization_list = _capitalization_list.to_ctype();
    }
    if !_profane.is_empty() {
        profane = _profane.to_ctype();
    }

    ExitCause::Ok.exit_code()
}

// Implement Default for lib_cc_decode
impl Default for lib_cc_decode {
    fn default() -> Self {
        // Create a default instance with all fields zeroed/nulled
        Self {
            dtvcc_rust: std::ptr::null_mut(),
            dtvcc: std::ptr::null_mut(),
            write_format: ccx_output_format::CCX_OF_SRT, // Default to SRT
            cc_stats: [0; 4],
            timing: std::ptr::null_mut(),
            current_field: 0,
            extraction_start: ccx_boundary_time::default(),
            extraction_end: ccx_boundary_time::default(),
            processed_enough: 0,
            saw_caption_block: 0,
            context_cc608_field_1: std::ptr::null_mut(),
            context_cc608_field_2: std::ptr::null_mut(),
            no_rollup: 0,
            noscte20: 0,
            fix_padding: 0,
            subs_delay: 0,
            extract: 0,
            fullbin: 0,
            dec_sub: unsafe { std::mem::zeroed() },
            in_bufferdatatype: unsafe { std::mem::zeroed() },
            hauppauge_mode: 0,
            frames_since_last_gop: 0,
            saw_gop_header: 0,
            max_gop_length: 0,
            last_gop_length: 0,
            total_pulldownfields: 0,
            total_pulldownframes: 0,
            program_number: 0,
            list: unsafe { std::mem::zeroed() },
            codec: unsafe { std::mem::zeroed() },
            has_ccdata_buffered: 0,
            is_alloc: 0,
            avc_ctx: std::ptr::null_mut(),
            private_data: std::ptr::null_mut(),
            current_hor_size: 0,
            current_vert_size: 0,
            current_aspect_ratio: 0,
            current_frame_rate: 0,
            no_bitstream_error: 0,
            saw_seqgoppic: 0,
            in_pic_data: 0,
            current_progressive_sequence: 0,
            current_pulldownfields: 0,
            temporal_reference: 0,
            picture_coding_type: unsafe { std::mem::zeroed() },
            num_key_frames: 0,
            picture_structure: 0,
            repeat_first_field: 0,
            progressive_frame: 0,
            pulldownfields: 0,
            top_field_first: 0,
            stat_numuserheaders: 0,
            stat_dvdccheaders: 0,
            stat_scte20ccheaders: 0,
            stat_replay5000headers: 0,
            stat_replay4000headers: 0,
            stat_dishheaders: 0,
            stat_hdtv: 0,
            stat_divicom: 0,
            false_pict_header: 0,
            maxtref: 0,
            cc_data_count: [0; SORTBUF],
            cc_fts: [0; SORTBUF],
            cc_data_pkts: [[0; 10*31*3+1]; SORTBUF],
            anchor_seq_number: 0,
            xds_ctx: std::ptr::null_mut(),
            vbi_decoder: std::ptr::null_mut(),
            writedata: None,
            ocr_quantmode: 0,
            prev: std::ptr::null_mut(),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_verify_parity() {
        // Odd parity
        assert!(verify_parity(0b1010001));

        // Even parity
        assert!(!verify_parity(0b1000001));
    }

    #[test]
    fn test_validate_cc_pair() {
        // Valid CEA-708 data
        let mut cc_block = [0x97, 0x1F, 0x3C];
        assert!(validate_cc_pair(&mut cc_block));

        // Invalid CEA-708 data
        let mut cc_block = [0x93, 0x1F, 0x3C];
        assert!(!validate_cc_pair(&mut cc_block));

        // Valid CEA-608 data
        let mut cc_block = [0x15, 0x2F, 0x7D];
        assert!(validate_cc_pair(&mut cc_block));
        // Check for replaced bit when 1st byte doesn't pass parity
        assert_eq!(cc_block[1], 0x7F);

        // Invalid CEA-608 data
        let mut cc_block = [0x15, 0x2F, 0x5E];
        assert!(!validate_cc_pair(&mut cc_block));
    }

    #[test]
    fn test_do_cb() {
        let mut dtvcc_ctx = utils::get_zero_allocated_obj::<dtvcc_ctx>();
        let mut dtvcc = Dtvcc::new(&mut dtvcc_ctx);

        let mut decoder_ctx = lib_cc_decode::default();
        let cc_block = [0x97, 0x1F, 0x3C];

        assert!(do_cb(&mut decoder_ctx, &mut dtvcc, &cc_block));
        assert_eq!(decoder_ctx.current_field, 3);
        assert_eq!(decoder_ctx.cc_stats[3], 1);
        assert_eq!(decoder_ctx.processed_enough, 0);
        assert_eq!(unsafe { cb_708 }, 11);
    }
}
